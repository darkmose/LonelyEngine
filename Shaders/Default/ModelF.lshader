#version 330 core

in vec2 TexturePos;
in vec3 Normal;
in vec3 FragPos;

	struct Texture
	{
	sampler2D texture_diffuse1;
	sampler2D texture_specular1;
	};
	struct  MatProp
	{
		vec3 objectColor;
		float ambient;
		float diffuse;
		float specular;		
		float specularStr;
	};

	
	struct DirectionalL
	{
		vec3 direction;
		vec3 color;	
		float strengh;
	};
	
	struct PointL
	{
		vec3 position;
		vec3 color;
		float strengh;
		float Kc;
		float Kl;
		float Kq;
	};
	
	struct SpotL
	{
		vec3 position;
		vec3 color;
		vec3 direction;
		float strengh;
		float innerCutOff;
		float outerCutOff;
	};
	
	uniform Texture Textures;
	uniform MatProp Props;
	uniform PointL Point[1];
	//uniform SpotL Spot[1];
	//uniform DirectionalL Directional[1];
	uniform vec3 cameraPos;
	
	vec3 DirectionOut(in DirectionalL,in vec3);
	vec3 SpotOut(in SpotL,in vec3);
	vec3 PointOut(in PointL,in vec3);
	vec3 texCol(sampler2D);

out vec4 color;

void main()
{
    vec3 cameraDir = normalize(cameraPos - FragPos);
    vec3 result;
   
  //  for(int i = 0; i < 1; i++){
   // result += DirectionOut(Directional[i],cameraDir);}
    
	for(int i = 0; i < 1; i++){
	result += PointOut(Point[i], cameraDir);}
    
	//for(int i = 0; i < 1; i++){
    //result += SpotOut(Spot[i], cameraDir); }   
    
    color = vec4(result,1.f);//vec4(result,1.f);
}

vec3 texCol(sampler2D _texture)
{
	return vec3(texture(_texture, TexturePos));
}

vec3 DirectionOut(in DirectionalL dir,in vec3 cameraDir)
{
	vec3 lightDir = normalize(-dir.direction);
	vec3 ambient = dir.color * Props.ambient;
	float d = max(dot(lightDir,Normal),0.f);
	vec3 diffuse = dir.color * Props.diffuse * d;
	vec3 reflectLight = reflect(-lightDir, Normal);
	float s = pow(max(dot(cameraDir, reflectLight), 0.0), Props.specularStr)*Props.specular;
	vec3 specular = s * Props.specular * dir.color;
	
	return ((ambient + diffuse) * texCol(Textures.texture_diffuse1) + specular*texCol(Textures.texture_specular1))* dir.strengh;
}

vec3 PointOut(in PointL point,in vec3 cameraDir)
{
	float distance = length(point.position - FragPos);
	float attenuation = 1.0f/(point.Kc + point.Kl*distance + point.Kq*distance*distance);
	
	vec3 lightDir = normalize(point.position - FragPos);
	vec3 ambient = point.color * Props.ambient;
	
	float d = max(dot(lightDir,Normal),0.f) * attenuation;
	vec3 diffuse = point.color * Props.diffuse * d ;
	vec3 reflectLight = reflect(-lightDir, Normal);
	float s = pow(max(dot(cameraDir, reflectLight), 0.0), Props.specularStr)*Props.specular*attenuation;
	vec3 specular = s * Props.specular * point.color;
	
	return ((ambient + diffuse) * texCol(Textures.texture_diffuse1) + specular*texCol(Textures.texture_specular1))* point.strengh;
}

vec3 SpotOut(in SpotL spot,in vec3 cameraDir)
{
	vec3 ambient = spot.color * Props.ambient;	
	
	vec3 lightDir = normalize(spot.position - FragPos);
	float theta = dot(lightDir, normalize(-spot.direction));
	if(theta > spot.outerCutOff){return ambient;}
	else
	{
		float epsilon = spot.innerCutOff - spot.outerCutOff;
		float intensity = clamp((theta - spot.outerCutOff) / epsilon, 0.0, 1.0);
		vec3 diffuse = spot.color * Props.diffuse * intensity;
		vec3 reflectLight = reflect(-lightDir, Normal);
		float spec = pow(max(dot(cameraDir, reflectLight), 0.0), Props.specularStr)*Props.specular;
		vec3 specular = spec * spot.color * intensity;
		
		return ((ambient + diffuse) * texCol(Textures.texture_diffuse1) + specular*texCol(Textures.texture_specular1)) * spot.strengh;
	}	
}