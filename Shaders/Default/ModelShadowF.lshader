#version 330 core

layout (std140) uniform Camera
{
	vec3 cameraPos;
};

layout (std140) uniform MatProps
{
	float ambient;
	float diffuse;
	float specular;
	float specularStr;
};


in VS_OUT {
 vec3 FragPos;
 vec3 Normal;
 vec2 TexCoords;
 vec4 FragPosLight;
} fs_in;
uniform sampler2D shadowMap;
	struct Texture
	{
		sampler2D texture_diffuse1;
		sampler2D texture_specular1;
	};	
	struct DirectionalL
	{
		vec3 direction;
		vec3 color;	
		float strengh;
	};	
	struct PointL
	{
		vec3 position;
		vec3 color;
		float strengh;
		float Kc;
		float Kl;
		float Kq;
	};	
	struct SpotL
	{
		vec3 position;
		vec3 color;
		vec3 direction;
		float strengh;
		float innerCutOff;
		float outerCutOff;
	};
	
	uniform Texture Textures;
//	uniform PointL Point[1];
	uniform DirectionalL Directional[1];
	
	vec3 DirectionOut(in DirectionalL,in vec3);
	float ShadowCalculation(in vec4);
	//vec3 SpotOut(in SpotL,in vec3);
	//vec3 PointOut(in PointL,in vec3);
	vec3 texCol(sampler2D);

out vec4 color;

void main()
{
   // vec3 cameraDir = normalize(cameraPos - fs_in.FragPos);
   // vec3 result;
    
	//for(int i = 0; i < 1; i++){
	//result += DirectionOut(Directional[i], cameraDir);}

    
    //color = vec4(result,1.f);
	float depthValue = texture(shadowMap, fs_in.TexCoords).r;
	color = vec4(vec3(depthValue), 1.0);	
}

vec3 texCol(sampler2D _texture)
{
	return vec3(texture(_texture, fs_in.TexCoords));
}

vec3 DirectionOut(in DirectionalL dir,in vec3 cameraDir)
{
	vec3 lightDir = normalize(-dir.direction);
	vec3 _ambient = dir.color * ambient;
	float d = max(dot(lightDir,normalize(fs_in.Normal)),0.f);
	vec3 _diffuse = dir.color * diffuse * d;
	vec3 reflectLight = reflect(-lightDir, normalize(fs_in.Normal));
	float s = pow(max(dot(cameraDir, reflectLight), 0.0), specularStr);
	vec3 _specular = s * specular * dir.color;
	float shadow = ShadowCalculation(fs_in.FragPosLight);
	
	vec3 text_diff = texCol(Textures.texture_diffuse1);
	vec3 text_spec = texCol(Textures.texture_specular1);
		
	_ambient *= text_diff;
	_diffuse *= (1.f - shadow) * text_diff;
	_specular *= (1.f - shadow)* text_spec;
	
	return (_ambient + _diffuse + _specular)* dir.strengh;
}

float ShadowCalculation(vec4 fragPosLight)
{
 vec3 projCoords = fragPosLight.xyz / fragPosLight.w;
 projCoords = projCoords * 0.5 + 0.5;
 float closestDepth = texture(shadowMap, projCoords.xy).r;
 float currentDepth = projCoords.z;
 float shadow = currentDepth > closestDepth ? 1.0 : 0.0;
	return shadow;
}



/*
vec3 PointOut(in PointL point,in vec3 cameraDir)
{
	float distance = length(point.position - FragPos);
	float attenuation = 1.0f/(point.Kc + point.Kl*distance + point.Kq*distance*distance);
	
	vec3 lightDir = normalize(point.position - FragPos);
	vec3 ambient = point.color * ambient;
	
	float d = max(dot(lightDir,Normal),0.f) * attenuation;
	vec3 diffuse = point.color * diffuse * d ;
	vec3 reflectLight = reflect(-lightDir, Normal);
	float s = pow(max(dot(cameraDir, reflectLight), 0.0), specularStr)*specular*attenuation;
	vec3 specular = s * specular * point.color;
	
	return ((ambient + diffuse) * texCol(Textures.texture_diffuse1) + specular*texCol(Textures.texture_specular1))* point.strengh;
}

vec3 SpotOut(in SpotL spot,in vec3 cameraDir)
{
	vec3 ambient = spot.color * ambient;	
	
	vec3 lightDir = normalize(spot.position - FragPos);
	float theta = dot(lightDir, normalize(-spot.direction));
	if(theta > spot.outerCutOff){return ambient;}
	else
	{
		float epsilon = spot.innerCutOff - spot.outerCutOff;
		float intensity = clamp((theta - spot.outerCutOff) / epsilon, 0.0, 1.0);
		vec3 diffuse = spot.color * diffuse * intensity;
		vec3 reflectLight = reflect(-lightDir, Normal);
		float spec = pow(max(dot(cameraDir, reflectLight), 0.0), specularStr)*specular;
		vec3 specular = spec * spot.color * intensity;
		
		return ((ambient + diffuse) * texCol(Textures.texture_diffuse1) + specular*texCol(Textures.texture_specular1)) * spot.strengh;
	}	
}*/