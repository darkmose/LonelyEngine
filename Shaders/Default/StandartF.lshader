#version 330 core

in vec2 TexturePos;
in vec3 Normal;
in vec3 FragPos;

	struct Texture
	{
		sampler2D texture_diffuse1;
	};
	struct  MatProp
	{
		vec3 objectColor;
		float ambient;
		float diffuse;
		float specular;		
		float specularStr;
	};

	
	struct DirectionalL
	{
		vec3 direction;
		vec3 color;	
		float strengh;
	};
	
	struct PointL
	{
		vec3 position;
		vec3 color;
		float strengh;
		float Kc;
		float Kl;
		float Kq;
	};
	
	struct SpotL
	{
		vec3 position;
		vec3 color;
		vec3 direction;
		float strengh;
		float innerCutOff;
		float outerCutOff;
	};
	
	uniform Texture Textures;
	uniform MatProp Props;
<<<<<<< HEAD
	//uniform PointL Point[1];
	//uniform SpotL Spot[1];
	uniform DirectionalL Directional[1];
=======
	uniform PointL Point[4];
	uniform SpotL Spot[1];
	uniform DirectionalL Directional[4];
>>>>>>> parent of 065523d... 7
	uniform vec3 cameraPos;
	
	vec3 DirectionOut(in DirectionalL,in vec3,in vec3);
	vec3 SpotOut(in SpotL,in vec3,in vec3);
	vec3 PointOut(in PointL,in vec3,in vec3,in vec3);

out vec4 color;



void main()
{
    vec3 cameraDir = normalize(cameraPos - FragPos);
	vec3 result = vec3(0);
   
<<<<<<< HEAD
    for(int i = 0; i < 1; i++){
    result += DirectionOut(Directional[i],cameraDir);}
    
	//for(int i = 0; i < 1; i++){
	//result += PointOut(Point[i], cameraDir);}
=======
    for(int i = 0; i < 4; i++){
    result += DirectionOut(Directional[i],Normal,cameraDir);}
    
//	for(int i = 0; i < 4; i++){
	//result += PointOut(Point[i], Normal, FragPos, cameraDir);}
>>>>>>> parent of 065523d... 7
    
//	for(int i = 0; i < 1; i++){
//  result += SpotOut(Spot[i], FragPos, cameraDir); }   
    
    color = vec4(result * Props.objectColor, 1.0);	
}



vec3 DirectionOut(in DirectionalL dir,in vec3 normal,in vec3 cameraDir)
{
	vec3 lightDir = normalize(-dir.direction);
	vec3 ambient = dir.color * Props.ambient ;
	float d = max(dot(lightDir,normal),0.f);
	vec3 diffuse = dir.color * Props.diffuse * d;
	vec3 reflectLight = reflect(-lightDir, normal);
	float s = pow(max(dot(cameraDir, reflectLight), 0.0), Props.specularStr)*Props.specular;
	vec3 specular = s * Props.specular * dir.color;
	
	return (ambient + diffuse * vec3(texture(Textures.texture_diffuse1, TexturePos)) + specular)* dir.strengh;
}

vec3 PointOut(in PointL point,in vec3 normal,in vec3 fragPos,in vec3 cameraDir)
{
	float distance = length(point.position - fragPos);
	float attenuation = 1.0f/(point.Kc + point.Kl*distance + point.Kq*distance*distance);
	
	vec3 lightDir = normalize(point.position - fragPos);
	vec3 ambient = point.color * Props.ambient;
	
	float d = max(dot(lightDir,normal),0.f) * attenuation;
	vec3 diffuse = point.color * Props.diffuse * d ;
	vec3 reflectLight = reflect(-lightDir, normal);
	float s = pow(max(dot(cameraDir, reflectLight), 0.0), Props.specularStr)*Props.specular*attenuation;
	vec3 specular = s * Props.specular * point.color;
	
	return (ambient + diffuse * vec3(texture(Textures.texture_diffuse1, TexturePos)) + specular)* point.strengh;
}

vec3 SpotOut(in SpotL spot,in vec3 fragPos,in vec3 cameraDir)
{
	vec3 ambient = spot.color * Props.ambient;	
	
	vec3 lightDir = normalize(spot.position - fragPos);
	float theta = dot(lightDir, -spot.direction);
	if(theta < spot.outerCutOff){}
	else
	{
		float epsilon = spot.innerCutOff - spot.outerCutOff;
		float intensity = clamp((theta - spot.outerCutOff) / epsilon, 0.0, 1.0);
		vec3 diffuse = spot.color * Props.diffuse * intensity;
		vec3 reflectLight = reflect(-lightDir, Normal);
		float spec = pow(max(dot(cameraDir, reflectLight), 0.0), Props.specularStr)*Props.specular;
		vec3 specular = spec * spot.color * intensity;
		
<<<<<<< HEAD
		return (ambient + diffuse * vec3(texture(Textures.texture_diffuse1, TexturePos)) + specular) * spot.strengh;
	}	
=======
		return (ambient + diffuse + specular) * spot.strengh;
	}
	
	return vec3(0);
>>>>>>> parent of 065523d... 7
}