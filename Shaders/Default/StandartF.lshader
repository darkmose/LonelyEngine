#version 330 core

in vec2 TexturePos;
in vec3 Normal;
in vec3 FragPos;

layout (std140) uniform Camera
{
	vec3 cameraPos;
};
layout (std140) uniform MatProps
{
	float _ambient;
	float _diffuse;
	float _specular;
	float _specularStr;
};

	struct Texture
	{
		sampler2D texture_diffuse1;	
	};
	struct  MatProp
	{
		vec3 objectColor;
	};	
	
	struct DirectionalL
	{
		vec3 direction;
		vec3 color;	
		float strengh;
	};
	
	struct PointL
	{
		vec3 position;
		vec3 color;
		float strengh;
		float Kc;
		float Kl;
		float Kq;
	};
	
	struct SpotL
	{
		vec3 position;
		vec3 color;
		vec3 direction;
		float strengh;
		float innerCutOff;
		float outerCutOff;
	};
	
	uniform Texture Textures;
	uniform MatProp Props;
	uniform PointL Point[1];
	
	vec3 DirectionOut(in DirectionalL,in vec3);
	vec3 SpotOut(in SpotL,in vec3);
	vec3 PointOut(in PointL,in vec3);

out vec4 color;



void main()
{
    vec3 cameraDir = normalize(cameraPos - FragPos);
	vec3 result;
    
	for(int i = 0; i < 1; i++){
	result += PointOut(Point[i], cameraDir);}
    
    color = vec4(result * Props.objectColor, 1.0) * texture(Textures.texture_diffuse1, TexturePos);	
}



vec3 DirectionOut(in DirectionalL dir,in vec3 cameraDir)
{
	vec3 lightDir = normalize(-dir.direction);
	vec3 ambient = dir.color * _ambient;
	float d = max(dot(lightDir,Normal),0.f);
	vec3 diffuse = dir.color * _diffuse * d;
	vec3 reflectLight = reflect(-lightDir, Normal);
	float s = pow(max(dot(cameraDir, reflectLight), 0.0), _specularStr)*_specular;
	vec3 specular = s * dir.color;
	
	return (ambient + diffuse + specular)* dir.strengh;
}

vec3 PointOut(in PointL point,in vec3 cameraDir)
{
	float distance = length(point.position - FragPos);
	float attenuation = 1.0f/(point.Kc + point.Kl*distance + point.Kq*distance*distance);
	
	vec3 lightDir = normalize(point.position - FragPos);
	vec3 ambient = point.color * _ambient;
	
	float d = max(dot(lightDir,Normal),0.f) * attenuation;
	vec3 diffuse = point.color * _diffuse * d ;
	vec3 reflectLight = reflect(-lightDir, Normal);
	float s = pow(max(dot(cameraDir, reflectLight), 0.0), _specularStr)*_specular*attenuation;
	vec3 specular = s * point.color;
	
	return (ambient + diffuse + specular)* point.strengh;
}

vec3 SpotOut(in SpotL spot,in vec3 cameraDir)
{
	vec3 ambient = spot.color * _ambient;	
	
	vec3 lightDir = normalize(spot.position - FragPos);
	float theta = dot(lightDir, normalize(-spot.direction));
	if(theta > spot.outerCutOff){return ambient;}
	else
	{
		float epsilon = spot.innerCutOff - spot.outerCutOff;
		float intensity = clamp((theta - spot.outerCutOff) / epsilon, 0.0, 1.0);
		vec3 diffuse = spot.color * _diffuse * intensity;
		vec3 reflectLight = reflect(-lightDir, Normal);
		float spec = pow(max(dot(cameraDir, reflectLight), 0.0), _specularStr)*_specular;
		vec3 specular = spec * spot.color * intensity;
		
		return (ambient + diffuse + specular) * spot.strengh;
	}	
}